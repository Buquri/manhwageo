<!DOCTYPE html>

<html lang="ka">

<head>

  <meta charset="UTF-8">

  <title>Manhwageo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta name="description" content="Manhwageo - ქართული მანჰვების ონლაინ ბიბლიოთეკა. წაიკითხეთ საუკეთესო მანჰვები ქართულ ენაზე.">

  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

  <style>

    /* სტილების გადატვირთვა კონსისტენტურობისთვის */

    * {

      box-sizing: border-box;

      margin: 0; /* შესწორებულია: CSS თვისებებს სჭირდებათ ერთეულები */

      padding: 0; /* შესწორებულია: CSS თვისებებს სჭირდებათ ერთეულები */

    }



    body {

      font-family: 'Poppins', sans-serif;

      display: flex;

      flex-direction: column;

      gap: 10px;

      margin: 0;

      padding: 10px; /* დავტოვე მცირე padding body-ზე */

      background-color: #E9967A;

      color: #fff;

      overflow-x: hidden;

      min-height: 100vh;

      position: relative;

    }



    /* მთავარი გრიდი (განლაგება) */

    .main-grid {

      display: grid;

      grid-template-columns: 1fr; /* Default to single column for mobile */

      gap: 10px;

      flex-grow: 1;

    }



    @media (min-width: 768px) { /* Two columns for larger screens */

      .main-grid {

        grid-template-columns: repeat(2, 1fr);

        max-width: 1000px; /* ზღუდავს გრიდის მაქსიმალურ სიგანეს დესკტოპზე */

        margin: 0 auto; /* ცენტრირებს გრიდს */

      }

    }



    /* ყუთების (ბოქსების) სტილები */

    .box {

      border: 2px solid #333;

      overflow: hidden;

      position: relative;

      background-color: #197; /* სარეზერვო ფერი, თუ ფონის სურათი არ იტვირთება */

      background-size: cover; /* უზრუნველყოფს, რომ სურათი მთლიანად ფარავდეს ყუთს */

      background-position: left; /* აღდგენილია left-ზე, როგორც თქვენ გქონდათ */

      background-repeat: no-repeat; /* ხელს უშლის სურათის გამეორებას */

      display: flex;

      flex-direction: column;

      justify-content: flex-end; /* კონტენტს ათავსებს ქვედა ნაწილში */

      align-items: flex-start; /* კონტენტს ათავსებს მარცხენა ნაწილში */

      border-radius: 6px;

      

      width: 100%; /* ყუთი იკავებს მისი სვეტის 100%-ს */

      aspect-ratio: 730 / 1050; /* 730px სიგანე, 1050px სიმაღლე - ასპექტის თანაფარდობის შენარჩუნება */

      /* min-height, height, max-height ამოღებულია, რადგან aspect-ratio ზრუნავს სიმაღლეზე */



      box-sizing: border-box; /* დარწმუნდით, რომ padding და border არ ზრდის საერთო ზომას */

      padding: 5px; /* მცირე შიდა დაშორება ტექსტისა და ღილაკებისთვის */

      cursor: pointer;

      transition: transform 0.2s ease, box-shadow 0.2s ease;

    }



    .box:hover {

      transform: translateY(-3px);

      box-shadow: 4px 4px 10px rgba(0,0,0,0.2);

    }







    







    /* ფონის სურათები თითოეული ყუთისთვის */



    .box.first {



      background-image: url('images/bg-main.jpg');



    }







    .box.second {



      background-image: url('images/bg-2.jpg');



    }







    .box.third {



      background-image: url('images/bg-3.jpg');



    }







    .box.fourth {



      background-image: url('images/bg-4.jpg');



    }







    /* --- ახალი ყუთების ფონის სურათები ვიდეო მანჰვებისთვის --- */



    .box.fifth {



      background-image: url('images/bg-5.jpg');



    }







    .box.sixth {



      background-image: url('images/bg-6.jpg');



    }



    /* --- ახალი ყუთების ფონის სურათების დასასრული --- */







    /* სათაურებისა და ღილაკების ძირითადი სტილები ყუთებში */



    .box h2,



    .box button {



      position: relative;



      z-index: 2; /* დარწმუნდით, რომ გადაფარვაზე მაღლაა */



      color: white;



      background-color: rgba(0, 0, 0, 0.7);



      padding: 8px 12px;



      border: none;



      border-radius: 10px;



      margin: 5px 10px 10px 15px; /* მორგებული ზღვარი კიდეებიდან დაშორებისთვის */



      cursor: pointer;



      transition: background-color 0.3s ease;



      font-size: 0.8em; /* პატარა შრიფტი მობილურისთვის */



    }







    @media (min-width: 768px) {



      .box h2, .box button {



        font-size: 1em;



      }



    }







    .box button:hover:not(:disabled) {



      background-color: rgba(0, 0, 0, 0.9);



    }







    .box button:disabled {



      cursor: not-allowed;



      opacity: 0.5;



      background-color: rgba(50, 50, 50, 0.7);



    }







    /* ნახვების მრიცხველის სტილები */



    .views-counter {



      position: relative;



      z-index: 2; /* დარწმუნდით, რომ გადაფარვაზე მაღლაა */



      color: #ccc;



      background-color: rgba(0, 0, 0, 0.7);



      padding: 5px 10px;



      border-radius: 8px;



      margin: 0px 10px 5px 10px; /* ღილაკზე მაღლა გასწორება */



      font-size: 0.8em;



      display: flex; /* ხატულისა და ტექსტის გასასწორებლად */



      align-items: center;



      gap: 5px; /* სივრცე ხატულასა და ტექსტს შორის */



      align-self: flex-start; /* მიმყვება ფლექს კონტეინერის დასაწყისს (ქვედა-მარცხენა) */



    }







    .views-counter i {



      color: #ff4444; /* ხატულის ფერი */



    }







    /* მოდალური ფანჯრების სტილები (თავების არჩევა, თავის ნახვა) */



    .modal {



      position: fixed;



      top: 0;



      left: 0;



      width: 100vw;



      height: 100vh;



      background-color: rgba(0, 0, 0, 0.95);



      display: none; /* ნაგულისხმევად დამალულია */



      justify-content: center;



      align-items: center;



      z-index: 999;



    }







    .overlay {



      background-color: rgba(0, 0, 0, 0.85);



      padding: 15px; /* პატარა padding მობილურისთვის */



      border-radius: 8px;



      max-width: 95vw; /* უფრო ფართო მობილურისთვის */



      max-height: 98vh; /* უფრო მაღალი მობილურისთვის */



      display: flex;



      flex-direction: column;



    }







    #chapterModal .overlay {



      padding: 0; /* padding არ აქვს თავების სურათებისთვის */



      max-width: 100vw;



      max-height: 130vh;



      border-radius: 0;



      background-color: black; /* უზრუნველყოფს სრულად შავ ფონს */



    }







    /* თავების ღილაკების სტილები */



    .chapter-buttons {



      display: grid;



      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* პატარა min-width მობილურისთვის */



      gap: 10px;



      margin-top: 15px;



    }







    .chapter-buttons button {



      padding: 10px 15px;



      background-color: #ff4444;



      border: none;



      color: white;



      font-size: 0.9em; /* პატარა შრიფტი მობილურისთვის */



      cursor: pointer;



      border-radius: 5px;



      transition: background-color 0.5s ease, transform 0.8s ease;



    }







    @media (min-width: 768px) {



      .chapter-buttons {



        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));



      }



      .chapter-buttons button {



        font-size: 1em;



      }



    }







    .chapter-buttons button:hover {



      background-color: #cc0000;



      transform: scale(1.03);



    }







    /* სურათების/ვიდეოების კონტეინერი */



    .images-container {



      display: flex;



      flex-direction: column;



      flex-grow: 1;



      overflow-y: scroll; /* სქროლის დაშვება */



      -ms-overflow-style: none; /* IE და Edge-სთვის */



      scrollbar-width: none; /* Firefox-ისთვის */



      margin-top: 0;



      background-color: black; /* უზრუნველყოფს შავ ფონს სურათებს შორის */



    }







    .images-container::-webkit-scrollbar {



        display: none; /* Chrome, Safari, Opera-სთვის */



    }







    .images-container img, .images-container video { /* სურათებისა და ვიდეოების სტილები */



      width: 100%;



      height: auto;



      display: block;



      border-radius: 0;



      opacity: 0;



      transform: translateY(20px);



      animation: fadeUp 0.5s ease forwards;



      max-width: 100%;



    }







    .loading-indicator {



        text-align: center;



        padding: 20px;



        font-size: 1.2em;



        color: #ddd;



    }







    @keyframes fadeUp {



      to {



        opacity: 1;



        transform: translateY(0);



      }



    }







    /* მოდალის სათაური */



    .modal-header {



        display: flex;



        flex-direction: column;



        align-items: flex-start;



        width: 100%;



        padding: 15px;



        background-color: rgba(0, 0, 0, 1);



        position: sticky;



        top: 0;



        z-index: 1000;



        transition: opacity 0.3s ease-out, visibility 0.3s ease-out;



        opacity: 1;



        visibility: visible;



    }







    #chapterModal .modal-header {



      padding: 10px 15px;



      background-color: rgba(0, 0, 0, 1);



    }







    .modal-header.hidden {



      opacity: 0;



      visibility: hidden;



      /* pointer-events: none; */



    }







    .modal-header h2 {



      margin: 0;



      font-size: 1.2em;



    }







    .modal-description {



      font-size: 0.9em;



      color: #b3da06;



      margin-top: 5px;



    }







    /* მოდალის კონტროლები (ქვედა ღილაკები) */



    .modal-controls {



      display: flex;



      justify-content: space-between;



      width: 100%;



      padding: 15px;



      background-color: rgba(0, 0, 0, 1);



      position: sticky;



      bottom: 0;



      z-index: 1000;



      transition: opacity 0.3s ease-out, visibility 0.3s ease-out;



      opacity: 1;



      visibility: visible;



    }







    #chapterModal .modal-controls {



      background-color: rgba(0, 0, 0, 1);



    }







    .modal-controls.hidden {



      opacity: 0;



      visibility: hidden;



    }







    .modal-controls .close-btn,



    .modal-controls .navigation-buttons button {



      margin: 0;



      padding: 8px 15px;



      font-size: 0.9em;



      flex: 1;



    }







    .modal-controls .close-btn {



      margin-left: 10px;



    }







    .navigation-buttons {



      display: flex;



      gap: 10px;



      flex-grow: 1;



    }







    .navigation-buttons button {



      background-color: #ff4444;



      border: none;



      color: white;



      cursor: pointer;



      border-radius: 5px;



      transition: background-color 0.3s ease, transform 0.2s ease;



    }







    .navigation-buttons button:hover:not(:disabled) {



        background-color: #cc0000;



        transform: scale(1.03);



    }



    .navigation-buttons button:disabled {



        background-color: #555;



        cursor: not-allowed;



        opacity: 0.6;



    }







    /* --- ანიმაციური პერსონაჟისა და კონტროლების სტილები --- */



    #animated-character {



      position: fixed;



      bottom: 10px;



      left: 0;



      width: 120px;



      height: 130px;



      background-size: contain;



      background-repeat: no-repeat;



      background-position: center;



      z-index: 99;



      image-rendering: pixelated;



    }







    #character-controls {



      position: fixed;



      bottom: 3px;



      right: 3px;



      z-index: 100;



      display: flex;



      flex-direction: column;



      gap: 5px;



    }







    #character-controls button {



      background-color: #6a5acd;



      color: white;



      border: none;



      padding: 3px 5px;



      border-radius: 3px;



      cursor: pointer;



      transition: background-color 0.3s ease;



      font-size: 0.7em;



    }







    #character-controls button:hover {



      background-color: #483d8b;



    }







    #character-controls button:disabled {



      background-color: #777;



      cursor: not-allowed;



      opacity: 0.7;



    }



    /* --- ანიმაციური პერსონაჟის სტილების დასასრული --- */



  </style>







  <script type="module">



    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";



    import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-analytics.js";



    import { getFirestore, doc, getDoc, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";







    const firebaseConfig = {



      apiKey: "AIzaSyBRcdavGb1Pi2eQlN6T_UbNue2bEa-8t-g",



      authDomain: "manhwageo.firebaseapp.com",



      projectId: "manhwageo",



      storageBucket: "manhwageo.firebasestorage.app",



      messagingSenderId: "822450839137",



      appId: "1:822450839137:web:7dcb516bf572ae08191420",



      measurementId: "G-3KMGGLE821"



    };







    const app = initializeApp(firebaseConfig);



    const analytics = getAnalytics(app);



    export const db = getFirestore(app);







    window.updateAndGetViews = async function(manhwaId) {



      const docRef = doc(db, "manhwa_views", manhwaId);







      try {



        const docSnap = await getDoc(docRef);



        let views = 0;







        if (docSnap.exists()) {



          views = docSnap.data().count + 1;



          await updateDoc(docRef, { count: views });



        } else {



          views = 1;



          await setDoc(docRef, { count: views });



        }



        return views;



      } catch (error) {



        console.error("ნახვების განახლების შეცდომა: ", error);



        return "შეცდომა";



      }



    };







    window.getInitialViews = async function(manhwaId) {



      const docRef = doc(db, "manhwa_views", manhwaId);



      try {



        const docSnap = await getDoc(docRef);



        if (docSnap.exists()) {



          return docSnap.data().count;



        } else {



          return 0;



        }



      } catch (error) {



        console.error("საწყისი ნახვების წამოღების შეცდომა: ", error);



        return "შეცდომა";



      }



    };







    document.addEventListener('DOMContentLoaded', async () => {



      const manhwaBoxes = document.querySelectorAll('.box[data-manhwa-id]');



      for (const box of manhwaBoxes) {



        const manhwaId = box.dataset.manhwaId;



        if (manhwaId) {



          const viewsElement = box.querySelector(`#views-${manhwaId}`);



          if (viewsElement) {



            const views = await window.getInitialViews(manhwaId);



            viewsElement.textContent = views;



          }



        }



      }



    });



  </script>



</head>



<body>







  <div class="main-grid">



    <div class="box first" data-manhwa-id="ch"> <h2>ბნელი ჯადოქრის დაბრუნება </h2>



      <div class="views-counter">



        <i class="fas fa-eye"></i> <span id="views-ch">0</span>



      </div>



      <button onclick="openChapterSelect('ch')">გახსნა / დახურვა</button>



    </div>







    <div class="box second" data-manhwa-id="w2_ch"> <h2>რკინის სისხლიანი ხმლის მქონე მონადირე</h2>



      <div class="views-counter">



        <i class="fas fa-eye"></i> <span id="views-w2_ch">0</span>



      </div>



      <button onclick="openChapterSelect('w2_ch')">გახსნა / დახურვა</button>



    </div>







    <div class="box third" data-manhwa-id="w3_ch"> <h2>მალე</h2>



      <div class="views-counter">



        <i class="fas fa-eye"></i> <span id="views-w3_ch">0</span>



      </div>



      <button onclick="openChapterSelect('w3_ch')" disabled>გახსნა / დახურვა</button>



    </div>







    <div class="box fourth" data-manhwa-id="w4_ch"> <h2>მალეე</h2>



      <div class="views-counter">



        <i class="fas fa-eye"></i> <span id="views-w4_ch">0</span>



      </div>



      <button onclick="openChapterSelect('w4_ch')" disabled>გახსნა / დახურვა</button>



    </div>







    <div class="box fifth" data-manhwa-id="video_manhwa1">



      <h2>მეხუთე </h2>



      <div class="views-counter">



        <i class="fas fa-eye"></i> <span id="views-video_manhwa1">0</span>



      </div>



      <button onclick="openChapterSelect('video_manhwa1')">გახსნა / დახურვა</button>



    </div>







    <div class="box sixth" data-manhwa-id="video_manhwa2">



      <h2>მეექვსე </h2>



      <div class="views-counter">



        <i class="fas fa-eye"></i> <span id="views-video_manhwa2">0</span>



      </div>



      <button onclick="openChapterSelect('video_manhwa2')">გახსნა / დახურვა</button>



    </div>



  </div>







  <div class="modal" id="chapterSelect">



    <div class="overlay">



      <div class="modal-header">



        <h2 id="chapterSelectTitle">თავების არჩევა</h2>



        <p id="manhwaDescription" class="modal-description"></p>



      </div>



      <div class="chapter-buttons" id="chapterButtons"></div>



      <div class="modal-controls">



        <button class="close-btn" onclick="toggleModal('chapterSelect')">დახურვა</button>



      </div>



    </div>



  </div>







  <div class="modal" id="chapterModal">



    <div class="overlay">



      <div class="modal-header" id="chapterModalHeader">



        <h2 id="chapterTitle">თავი</h2>



      </div>



      <div class="images-container" id="imagesContainer">



        <p class="loading-indicator">იტვირთება...</p>



      </div>



      <div class="modal-controls" id="chapterModalControls">



        <div class="navigation-buttons">



          <button id="prevChapterBtn" onclick="navigateChapter(-1)">წინა თავი</button>



          <button id="nextChapterBtn" onclick="navigateChapter(1)">შემდეგი თავი</button>



        </div>



        <button class="close-btn" onclick="toggleModal('chapterModal')">დახურვა</button>



      </div>



    </div>



  </div>







  <div id="animated-character"></div>



  <div id="character-controls">



    <button id="walkSpeedBtn">სიარული</button>



    <button id="runSpeedBtn">სირბილი</button>



    <button id="toggleAnimationBtn">გაჩერება / გაგრძელება</button>



  </div>







  <script>



    const manhwas = {



      "ch": {



        title: "ბნელი ჯადოქრის დაბრუნება 1",



        folder: "images/",



        description: "ამბავი ახალგაზრდა ჯადოქარზე, რომელიც წარსულიდან ბრუნდება, რათა შური იძიოს და სამყარო ბნელი ძალებისგან იხსნას. მისი გზა სავსეა გამოწვევებით და მოულოდნელი შეტაკებებით.",



        type: 'image',



        chapters: [



          { id: 1, pages: 16 },



          { id: 2, pages: 15 },



          { id: 3, pages: 20 },



          { id: 4, pages: 18 },



          { id: 5, pages: 17 },



          { id: 6, pages: 14 },



          { id: 7, pages: 12 },



          { id: 8, pages: 15 },



        ]



      },



      "w2_ch": {



        title: "რკინის სისხლიანი ხმლის მქონე მონადირე",



        folder: "images2/",



        description: "მონადირე, რომელსაც რკინის სისხლიანი ხმალი აქვს, იწყებს სახიფათო მოგზაურობას მონსტრების სამყაროში. მას მრავალი ბრძოლა ელის თავისი ბედის ასასრულებლად.",



        type: 'image',



        chapters: [



          { id: 1, pages: 10 },



          { id: 2, pages: 10 },



        ]



      },



      "w3_ch": {



        title: "მალე",



        folder: "images3/",



        description: "ეს მანჰვა მალე დაემატება. თვალყური ადევნეთ განახლებებს!",



        type: 'image',



        chapters: []



      },



      "w4_ch": {



        title: "მალეე",



        folder: "images4/",



        description: "უახლესი მანჰვა, რომელიც მალე იქნება ხელმისაწვდომი. მოემზადეთ ახალი თავგადასავლებისთვის!",



        type: 'image',



        chapters: []



      },



      "video_manhwa1": {



        title: "მეხუთე ",



        folder: "videos/",



        description: "აქ ჯერ არაფერია თუმცა მალე ყველაფერი იქნება,თქვენგან მხოლოდ აქტიურობაა საჭირო .",



        type: 'video',



        chapters: [



            { id: 1, file: "w5_v1.mp4" }



        ]



      },



      "video_manhwa2": {



        title: "მეექვსე  ",



        folder: "videos/",



        description: "მთავარია თქვენი აქტიურობა ყველაფერი იქნება .",



        type: 'video',



        chapters: [



            { id: 1, file: "w6_v1.mp4" }



        ]



      }



    };







    let currentManhwaId = null;



    let currentChapterId = null;



    let currentTotalPages = 0;







    let currentOpenModalId = null;



    let lastScrollTop = 0;



    let scrollTimeout;







    function toggleModal(id, doPushState = true) {



      const modal = document.getElementById(id);



      if (modal.style.display === 'flex') {



        modal.style.display = 'none';



        if (doPushState && currentOpenModalId === id) {



          history.back();



          currentOpenModalId = null;



        }



        if (id === 'chapterModal') {



          document.getElementById('chapterModalHeader').classList.remove('hidden');



          document.getElementById('chapterModalControls').classList.remove('hidden');



          clearTimeout(scrollTimeout);



        }



      } else {



        modal.style.display = 'flex';



        currentOpenModalId = id;



        if (doPushState) {



          history.pushState({ modal: id }, '', `#${id}`);



        }



      }



    }







    function openChapterSelect(manhwaId) {



      currentManhwaId = manhwaId;



      const manhwaData = manhwas[manhwaId];







      document.getElementById('chapterSelectTitle').textContent = manhwaData.title;



      document.getElementById('manhwaDescription').textContent = manhwaData.description;







      const chapterButtons = document.getElementById('chapterButtons');



      chapterButtons.innerHTML = '';







      if (manhwaData.chapters.length === 0) {



        chapterButtons.innerHTML = '<p style="text-align:center; color:#aaa; font-size: 0.9em;">თავები ჯერ არ არის დამატებული.</p>';



      } else {



        manhwaData.chapters.forEach(chapter => {



          const btn = document.createElement('button');



          btn.textContent = `თავი ${chapter.id}`;



          if (manhwaData.type === 'video') {



            btn.onclick = () => openChapter(chapter.id, chapter.file);



          } else {



            btn.onclick = () => openChapter(chapter.id, chapter.pages);



          }



          chapterButtons.appendChild(btn);



        });



      }







      const viewsElement = document.querySelector(`.box[data-manhwa-id="${manhwaId}"] .views-counter span`);



      if (viewsElement) {



        window.updateAndGetViews(manhwaId).then(views => {



          viewsElement.textContent = views;



        }).catch(error => {



          console.error("ნახვების განახლების შეცდომა openChapterSelect-დან: ", error);



          viewsElement.textContent = "შეცდომა";



        });



      }



      toggleModal('chapterSelect');



    }







    function openChapter(chapterId, contentData) {



      currentChapterId = chapterId;







      const imagesContainer = document.getElementById('imagesContainer');



      imagesContainer.innerHTML = '<p class="loading-indicator">იტვირთება...</p>';



      imagesContainer.scrollTop = 0;







      const chapterTitleElement = document.getElementById('chapterTitle');



      const manhwaData = manhwas[currentManhwaId];



      chapterTitleElement.textContent = `${manhwaData.title} - თავი ${chapterId}`;







      toggleModal('chapterSelect', false);



      toggleModal('chapterModal', true);







      document.getElementById('chapterModalHeader').classList.remove('hidden');



      document.getElementById('chapterModalControls').classList.remove('hidden');



      clearTimeout(scrollTimeout);







      setTimeout(() => {



        imagesContainer.innerHTML = '';







        if (manhwaData.type === 'image') {



          for (let i = 1; i <= contentData; i++) {



            const img = document.createElement('img');



            img.src = `${manhwaData.folder}${currentManhwaId}${chapterId}_page${i}.jpg`;



            img.alt = `თავი ${chapterId}, გვერდი ${i}`;



            img.loading = 'lazy';



            img.onerror = function() {



              this.src = 'images/placeholder.jpg';



              this.alt = 'სურათი ვერ მოიძებნა';



            };



            imagesContainer.appendChild(img);



          }



        } else if (manhwaData.type === 'video') {



          const video = document.createElement('video');



          video.src = `${manhwaData.folder}${contentData}`;



          video.controls = true;



          video.preload = 'auto';



          video.style.maxWidth = '100%';



          video.style.height = 'auto';



          video.style.display = 'block';



          video.autoplay = true;



          video.onerror = function() {



            console.error("ვიდეოს ჩატვირთვის შეცდომა: ", this.src);



            const errorDiv = document.createElement('div');



            errorDiv.textContent = 'ვიდეოს ჩატვირთვის შეცდომა.';



            errorDiv.style.color = 'red';



            errorDiv.style.textAlign = 'center';



            imagesContainer.appendChild(errorDiv);



          };



          imagesContainer.appendChild(video);



        }



        updateNavigationButtons();



      }, 500);



    }







    function updateNavigationButtons() {



        const prevBtn = document.getElementById('prevChapterBtn');



        const nextBtn = document.getElementById('nextChapterBtn');



        const manhwaData = manhwas[currentManhwaId];



        const currentChapterIndex = manhwaData.chapters.findIndex(ch => ch.id === currentChapterId);







        prevBtn.disabled = currentChapterIndex <= 0;



        nextBtn.disabled = currentChapterIndex >= manhwaData.chapters.length - 1;



    }







    function navigateChapter(direction) {



        const manhwaData = manhwas[currentManhwaId];



        const currentChapterIndex = manhwaData.chapters.findIndex(ch => ch.id === currentChapterId);



        const newChapterIndex = currentChapterIndex + direction;







        if (newChapterIndex >= 0 && newChapterIndex < manhwaData.chapters.length) {



            const newChapter = manhwaData.chapters[newChapterIndex];



            if (manhwaData.type === 'video') {



              openChapter(newChapter.id, newChapter.file);



            } else {



              openChapter(newChapter.id, newChapter.pages);



            }



        }



    }







    window.onpopstate = function(event) {



      if (document.getElementById('chapterModal').style.display === 'flex') {



        toggleModal('chapterModal', false);



        toggleModal('chapterSelect', true);



      } else if (document.getElementById('chapterSelect').style.display === 'flex') {



        toggleModal('chapterSelect', false);



      }



      currentOpenModalId = null;



    };







    window.onload = function() {



        if (window.location.hash) {



            const hash = window.location.hash.substring(1);



            if (hash === 'chapterSelect' || hash === 'chapterModal') {



                history.replaceState({}, '', window.location.pathname + window.location.search);



            }



        }



    };







    document.getElementById('imagesContainer').addEventListener('scroll', function() {



        const currentScrollTop = this.scrollTop;



        const header = document.getElementById('chapterModalHeader');



        const controls = document.getElementById('chapterModalControls');







        clearTimeout(scrollTimeout);







        if (currentScrollTop > lastScrollTop && currentScrollTop > 50) {



            header.classList.add('hidden');



            controls.classList.add('hidden');



        } else {



            header.classList.remove('hidden');



            controls.classList.remove('hidden');



            scrollTimeout = setTimeout(() => {



                if (currentScrollTop === this.scrollTop) {



                    header.classList.add('hidden');



                    controls.classList.add('hidden');



                }



            }, 2000);



        }



        lastScrollTop = currentScrollTop;



    });







    document.getElementById('imagesContainer').addEventListener('click', function() {



      const header = document.getElementById('chapterModalHeader');



      const controls = document.getElementById('chapterModalControls');



      if (header.classList.contains('hidden')) {



          header.classList.remove('hidden');



          controls.classList.remove('hidden');



          clearTimeout(scrollTimeout);



          scrollTimeout = setTimeout(() => {



              header.classList.add('hidden');



              controls.classList.add('hidden');



          }, 2000);



      }



    });







    document.addEventListener('DOMContentLoaded', () => {



      const character = document.getElementById('animated-character');



      const walkSpeedBtn = document.getElementById('walkSpeedBtn');



      const runSpeedBtn = document.getElementById('runSpeedBtn');



      const toggleAnimationBtn = document.getElementById('toggleAnimationBtn');







      const animationFolderPath = 'images/';







      const idleFrames = 1;



      const walkFrames = 2;



      const runFrames = 2;







      const characterWidth = 110;



      const characterHeight = 120;



      



      const walkSpeed = 0.5;



      const runSpeed = 3;



      



      const idleInterval = 500;



      const walkInterval = 450;



      const runInterval = 300;







      let currentX = 0;



      let direction = 1;



      let animationFrame = 1;



      let currentSpeed = 0;



      let currentInterval = idleInterval;



      let currentAnimationType = 'idle';







      let animationIntervalId;



      let movementIntervalId;



      let isAnimationRunning = false;







      character.style.width = `${characterWidth}px`;



      character.style.height = `${characterHeight}px`;







      function updateCharacterImage() {



        let maxFrames;



        if (currentAnimationType === 'idle') {



          maxFrames = idleFrames;



        } else if (currentAnimationType === 'walk') {



          maxFrames = walkFrames;



        } else {



          maxFrames = runFrames;



        }







        character.style.backgroundImage = `url('${animationFolderPath}animation_1_${currentAnimationType}_${animationFrame}.png')`;



        



        animationFrame++;



        if (animationFrame > maxFrames) {



          animationFrame = 1;



        }



      }







      function moveCharacter() {



        if (!isAnimationRunning || currentAnimationType === 'idle') {



          return;



        }







        currentX += direction * currentSpeed;







        const maxX = window.innerWidth - characterWidth;



        const minX = 0;







        if (currentX >= maxX) {



          currentX = maxX;



          direction = -1;



          character.style.transform = `translateX(${currentX}px) scaleX(-1)`;



        } else if (currentX <= minX) {



          currentX = minX;



          direction = 1;



          character.style.transform = `translateX(${currentX}px) scaleX(1)`;



        } else {



          character.style.transform = `translateX(${currentX}px) scaleX(${direction})`;



        }



      }







      function startAnimation() {



        clearInterval(animationIntervalId);



        clearInterval(movementIntervalId);







        animationIntervalId = setInterval(updateCharacterImage, currentInterval);



        movementIntervalId = setInterval(moveCharacter, 20);



      }







      function stopAnimation() {



        clearInterval(animationIntervalId);



        clearInterval(movementIntervalId);



        isAnimationRunning = false;



        currentAnimationType = 'idle';



        animationFrame = 1;



        updateCharacterImage();



      }







      stopAnimation();







      walkSpeedBtn.addEventListener('click', () => {



        currentSpeed = walkSpeed;



        currentInterval = walkInterval;



        currentAnimationType = 'walk';



        animationFrame = 1;



        isAnimationRunning = true;



        startAnimation();



      });







      runSpeedBtn.addEventListener('click', () => {



        currentSpeed = runSpeed;



        currentInterval = runInterval;



        currentAnimationType = 'run';



        animationFrame = 1;



        isAnimationRunning = true;



        startAnimation();



      });







      toggleAnimationBtn.addEventListener('click', () => {



        if (isAnimationRunning) {



          stopAnimation();



          toggleAnimationBtn.textContent = 'გაგრძელება';



        } else {



          isAnimationRunning = true;



          currentAnimationType = 'walk';



          currentSpeed = walkSpeed;



          currentInterval = walkInterval;



          animationFrame = 1;



          startAnimation();



          toggleAnimationBtn.textContent = 'გაჩერება';



        }



      });







      window.addEventListener('resize', () => {



        const maxX = window.innerWidth - characterWidth;



        if (currentX > maxX) {



          currentX = maxX;



          character.style.transform = `translateX(${currentX}px) scaleX(${direction})`;



        }



      });



    });



  </script>







</body>



</html>

